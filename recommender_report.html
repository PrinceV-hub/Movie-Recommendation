<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Recommender Systems Report</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals with Subtle Accents -->
    <!-- Application Structure Plan: The application is structured as a single-page narrative, guiding the user from foundational concepts to advanced topics. It starts with an introduction, followed by a deep dive into core methodologies (Collaborative vs. Content-Based), then explores advanced models and evaluation techniques. This thematic flow, combined with interactive visualizations and a new Gemini-powered "Explain" feature, is designed to build understanding progressively, making a complex topic more digestible than a simple reproduction of the report's structure. -->
    <!-- Visualization & Content Choices: Interactive charts are used to compare algorithm performance (RMSE), while diagrams built with HTML/CSS illustrate concepts like hybrid models. The new "Explain" button uses the Gemini API to fetch simple, contextual explanations, which are displayed in a modal. This approach avoids static images and SVG, adhering to the prompt's constraints, while enhancing user engagement and understanding. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #fdfdfd;
            color: #1a1a1a;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.35; /* Increased opacity for better visibility */
        }
        .content-container {
            position: relative;
            z-index: 1; /* Ensure content is on top of the canvas */
            background-color: rgba(253, 253, 253, 0.9); /* Add a semi-transparent background to make text readable */
        }
        .ai-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
    </style>
</head>
<body class="antialiased">
    <canvas id="particle-canvas"></canvas>

    <div class="content-container container mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold tracking-tight text-gray-900 sm:text-5xl">The World of Recommender Systems</h1>
            <p class="mt-4 text-lg text-gray-600">An interactive exploration of the models and methods that power personalized experiences.</p>
        </header>

        <nav class="sticky top-0 bg-white/80 backdrop-blur-md z-10 py-4 mb-12 border-b">
            <ul class="flex justify-center space-x-4 sm:space-x-8">
                <li><a href="#foundations" class="text-gray-600 hover:text-gray-900 font-medium">Foundations</a></li>
                <li><a href="#advanced" class="text-gray-600 hover:text-gray-900 font-medium">Advanced Models</a></li>
                <li><a href="#evaluation" class="text-gray-600 hover:text-gray-900 font-medium">Evaluation</a></li>
                <li><a href="#challenges" class="text-gray-600 hover:text-gray-900 font-medium">Challenges</a></li>
            </ul>
        </nav>

        <main>
            <section id="foundations" class="mb-16">
                <h2 class="text-3xl font-bold mb-6 text-center">Foundational Methodologies</h2>
                <p class="text-center text-gray-600 mb-8 max-w-3xl mx-auto">
                    At the heart of most recommender systems are two core approaches: Collaborative Filtering and Content-Based Filtering. This section breaks down how they work, their strengths, and their weaknesses. Explore the interactive diagram below to see how they compare and how they can be combined into more powerful hybrid systems.
                </p>
                <div class="grid md:grid-cols-2 gap-8 items-start">
                    <div class="bg-white p-6 rounded-lg shadow-sm border">
                        <h3 class="text-2xl font-semibold mb-4 text-center">Collaborative Filtering (CF)</h3>
                        <p class="text-gray-700 mb-4">
                            This method is based on the idea of "wisdom of the crowd." It recommends items to a user based on the preferences of other, similar users. It doesn't need to know anything about the items themselves, only how users have interacted with them.
                        </p>
                        <div class="mt-4">
                            <h4 class="font-semibold">Key Concepts:</h4>
                            <ul class="list-disc list-inside text-gray-600 mt-2 space-y-1">
                                <li><strong>User-Based:</strong> Finds users with similar tastes.</li>
                                <li><strong>Item-Based:</strong> Finds items that are frequently liked by the same users.</li>
                                <li><strong>Strengths:</strong> Can generate novel and surprising recommendations (serendipity).</li>
                                <li><strong>Weaknesses:</strong> Suffers from the "cold-start" problem for new users and items.</li>
                            </ul>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border">
                        <h3 class="text-2xl font-semibold mb-4 text-center">Content-Based Filtering (CBF)</h3>
                        <p class="text-gray-700 mb-4">
                           This approach recommends items that are similar to those a user has liked in the past. It relies on the features or attributes of the items, such as genre, director, or keywords.
                        </p>
                        <div class="mt-4">
                            <h4 class="font-semibold">Key Concepts:</h4>
                            <ul class="list-disc list-inside text-gray-600 mt-2 space-y-1">
                                <li><strong>User Profile:</strong> A model of the user's preferences based on item features.</li>
                                <li><strong>Item Profile:</strong> A set of features describing an item.</li>
                                <li><strong>Strengths:</strong> Solves the "cold-start" problem for new items.</li>
                                <li><strong>Weaknesses:</strong> Can lead to overspecialization and "filter bubbles."</li>
                            </ul>
                        </div>
                    </div>
                </div>
                 <div class="mt-8 bg-white p-6 rounded-lg shadow-sm border">
                    <h3 class="text-2xl font-semibold mb-4 text-center">Hybrid Systems</h3>
                     <p class="text-center text-gray-600 mb-6">Hybrid systems combine multiple recommendation strategies to leverage their strengths and mitigate their weaknesses. The diagram below illustrates a "Cascade Hybrid" model, a common and effective approach.</p>
                    <div class="flex flex-col items-center space-y-4">
                        <div class="p-4 bg-blue-100 text-blue-800 rounded-lg text-center">
                            <span class="font-bold">Initial Pool of Items</span>
                        </div>
                        <div class="text-2xl">⬇️</div>
                        <div class="p-4 bg-green-100 text-green-800 rounded-lg text-center">
                            <span class="font-bold">Content-Based Filter</span>
                            <p class="text-sm">Narrows down the list based on item features.</p>
                        </div>
                        <div class="text-2xl">⬇️</div>
                        <div class="p-4 bg-purple-100 text-purple-800 rounded-lg text-center">
                            <span class="font-bold">Collaborative Filter</span>
                            <p class="text-sm">Ranks the filtered list based on user behavior.</p>
                        </div>
                        <div class="text-2xl">⬇️</div>
                        <div class="p-4 bg-yellow-100 text-yellow-800 rounded-lg text-center">
                            <span class="font-bold">Final Recommendations</span>
                        </div>
                    </div>
                </div>
            </section>

            <section id="advanced" class="mb-16">
                <h2 class="text-3xl font-bold mb-6 text-center">Advanced Models</h2>
                 <p class="text-center text-gray-600 mb-8 max-w-3xl mx-auto">
                    Modern recommender systems often use more sophisticated models to capture complex patterns in user data. This section provides an overview of some of the most influential advanced architectures, including those based on deep learning.
                </p>
                <div class="space-y-6">
                    <div class="bg-white p-6 rounded-lg shadow-sm border flex flex-col sm:flex-row items-center justify-between">
                        <div class="mb-4 sm:mb-0 sm:w-2/3">
                            <h3 class="text-xl font-semibold">Matrix Factorization (MF)</h3>
                            <p class="text-gray-700 mt-2 max-w-lg">A model-based collaborative filtering technique that decomposes the user-item interaction matrix into lower-dimensionality matrices of user and item "latent factors."</p>
                        </div>
                        <div class="ai-buttons sm:w-1/3 sm:ml-4 flex flex-col space-y-2">
                             <button class="flex-shrink-0 bg-blue-500 text-white font-semibold py-2 px-4 rounded-full hover:bg-blue-600 transition-colors" onclick="explainConcept('Matrix Factorization')">✨ Explain</button>
                             <button class="flex-shrink-0 bg-purple-500 text-white font-semibold py-2 px-4 rounded-full hover:bg-purple-600 transition-colors" onclick="generateAnalogy('Matrix Factorization')">✨ Generate Analogy</button>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border flex flex-col sm:flex-row items-center justify-between">
                        <div class="mb-4 sm:mb-0 sm:w-2/3">
                            <h3 class="text-xl font-semibold">Deep Learning Models</h3>
                            <p class="text-gray-700 mt-2 max-w-lg">Neural networks can learn complex, non-linear relationships in data. Models like <strong>Neural Collaborative Filtering (NCF)</strong> and <strong>Wide & Deep</strong> combine the strengths of traditional methods with the power of deep learning.</p>
                        </div>
                        <div class="ai-buttons sm:w-1/3 sm:ml-4 flex flex-col space-y-2">
                            <button class="flex-shrink-0 bg-blue-500 text-white font-semibold py-2 px-4 rounded-full hover:bg-blue-600 transition-colors" onclick="explainConcept('Deep Learning Models for Recommender Systems')">✨ Explain</button>
                            <button class="flex-shrink-0 bg-purple-500 text-white font-semibold py-2 px-4 rounded-full hover:bg-purple-600 transition-colors" onclick="generateAnalogy('Deep Learning Models for Recommender Systems')">✨ Generate Analogy</button>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border flex flex-col sm:flex-row items-center justify-between">
                        <div class="mb-4 sm:mb-0 sm:w-2/3">
                            <h3 class="text-xl font-semibold">Graph-Based Models</h3>
                            <p class="text-gray-700 mt-2 max-w-lg">These models represent users and items as nodes in a graph, with interactions as edges. This allows the system to capture complex relationships and make recommendations by traversing the graph.</p>
                        </div>
                        <div class="ai-buttons sm:w-1/3 sm:ml-4 flex flex-col space-y-2">
                            <button class="flex-shrink-0 bg-blue-500 text-white font-semibold py-2 px-4 rounded-full hover:bg-blue-600 transition-colors" onclick="explainConcept('Graph-Based Recommender Systems')">✨ Explain</button>
                            <button class="flex-shrink-0 bg-purple-500 text-white font-semibold py-2 px-4 rounded-full hover:bg-purple-600 transition-colors" onclick="generateAnalogy('Graph-Based Recommender Systems')">✨ Generate Analogy</button>
                        </div>
                    </div>
                </div>
            </section>

            <section id="evaluation" class="mb-16">
                <h2 class="text-3xl font-bold mb-6 text-center">Model Evaluation</h2>
                <p class="text-center text-gray-600 mb-8 max-w-3xl mx-auto">
                    How do we know if a recommender system is effective? This section explores the key metrics used to evaluate model performance. The interactive chart below compares the Root Mean Squared Error (RMSE) of several common algorithms, a popular metric for prediction accuracy. A lower RMSE indicates a more accurate model.
                </p>
                <div class="bg-white p-6 rounded-lg shadow-sm border">
                    <div class="chart-container">
                        <canvas id="rmseChart"></canvas>
                    </div>
                </div>
            </section>

            <section id="challenges" class="mb-16">
                <h2 class="text-3xl font-bold mb-6 text-center">Practical Challenges</h2>
                 <p class="text-center text-gray-600 mb-8 max-w-3xl mx-auto">
                    Building a recommender system in the real world involves more than just choosing an algorithm. This section highlights some of the most significant practical challenges and the common strategies used to address them.
                </p>
                <div class="grid md:grid-cols-3 gap-8">
                    <div class="bg-white p-6 rounded-lg shadow-sm border">
                        <h3 class="text-xl font-semibold">The Cold-Start Problem</h3>
                        <p class="text-gray-700 mt-2">When a new user or item enters the system, there is no historical data to make recommendations from. This can be addressed with popularity-based models, content-based filtering, or hybrid approaches.</p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border">
                        <h3 class="text-xl font-semibold">Data Sparsity</h3>
                        <p class="text-gray-700 mt-2">In most real-world scenarios, the user-item interaction matrix is extremely sparse, meaning most users have only interacted with a tiny fraction of items. This makes it difficult to find similar users or items. Matrix factorization and deep learning models are effective at handling sparse data.</p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border">
                        <h3 class="text-xl font-semibold">Scalability</h3>
                        <p class="text-gray-700 mt-2">As the number of users and items grows, the computational cost of generating recommendations can become a bottleneck. This requires efficient algorithms, distributed computing, and techniques like item-based collaborative filtering, which allows for pre-computation of similarities.</p>
                    </div>
                </div>
            </section>
        </main>

        <footer class="text-center mt-12 text-gray-500">
            <p>&copy; 2025 Interactive Systems Inc. All rights reserved.</p>
        </footer>
    </div>

    <!-- Explanation Modal -->
    <div id="explanationModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden items-center justify-center p-4 z-50">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold">Explanation</h3>
                <button class="text-gray-400 hover:text-gray-600" onclick="hideExplanationModal()">&times;</button>
            </div>
            <div id="explanationContent" class="text-gray-700">
                <p>Loading...</p>
            </div>
        </div>
    </div>

    <script>
        const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=";
        const apiKey = "";
        const explanationModal = document.getElementById('explanationModal');
        const explanationContent = document.getElementById('explanationContent');

        function showExplanationModal() {
            explanationModal.style.display = 'flex';
        }

        function hideExplanationModal() {
            explanationModal.style.display = 'none';
        }

        async function fetchGeminiContent(prompt, systemPrompt) {
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };

            const apiUrl = `${GEMINI_API_URL}${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                return text || '<p class="text-red-500">An error occurred while generating the content. Please try again.</p>';
            } catch (error) {
                console.error('Error fetching content from Gemini API:', error);
                return '<p class="text-red-500">An error occurred while connecting to the service. Please check your network connection and try again.</p>';
            }
        }

        async function explainConcept(concept) {
            showExplanationModal();
            explanationContent.innerHTML = `<h3 class="text-xl font-bold mb-2">Explanation for ${concept}</h3><p>Loading...</p><p class="mt-2 text-sm text-gray-500">This may take a few moments...</p>`;
            const systemPrompt = "You are a friendly, knowledgeable tutor specializing in machine learning. Your task is to explain complex technical concepts in simple, easy-to-understand terms, as if explaining to a beginner. Use analogies if they help clarify the concept. Keep your response concise and direct, focusing on the core idea.";
            const userQuery = `Explain the concept of "${concept}" in recommender systems.`;
            const explanationText = await fetchGeminiContent(userQuery, systemPrompt);
            explanationContent.innerHTML = `<h3 class="text-xl font-bold mb-2">Explanation for ${concept}</h3>` + explanationText;
        }

        async function generateAnalogy(concept) {
            showExplanationModal();
            explanationContent.innerHTML = `<h3 class="text-xl font-bold mb-2">Analogy for ${concept}</h3><p>Loading...</p><p class="mt-2 text-sm text-gray-500">This may take a few moments...</p>`;
            const systemPrompt = "You are a friendly, creative tutor. Your task is to create a simple, easy-to-understand analogy for a complex machine learning concept. The analogy should be from everyday life and be very concise, focusing on the core idea.";
            const userQuery = `Create a simple analogy for "${concept}" in the context of recommender systems.`;
            const analogyText = await fetchGeminiContent(userQuery, systemPrompt);
            explanationContent.innerHTML = `<h3 class="text-xl font-bold mb-2">Analogy for ${concept}</h3>` + analogyText;
        }

        document.addEventListener('DOMContentLoaded', function () {
            const rmseData = {
                labels: ['SVD', 'KNN', 'NMF', 'CoClustering', 'SlopeOne'],
                datasets: [{
                    label: 'Test RMSE',
                    data: [0.89, 0.96, 0.95, 0.96, 0.94],
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.2)',
                        'rgba(54, 162, 235, 0.2)',
                        'rgba(255, 206, 86, 0.2)',
                        'rgba(75, 192, 192, 0.2)',
                        'rgba(153, 102, 255, 0.2)'
                    ],
                    borderColor: [
                        'rgba(255, 99, 132, 1)',
                        'rgba(54, 162, 235, 1)',
                        'rgba(255, 206, 86, 1)',
                        'rgba(75, 192, 192, 1)',
                        'rgba(153, 102, 255, 1)'
                    ],
                    borderWidth: 1
                }]
            };

            const rmseConfig = {
                type: 'bar',
                data: rmseData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Root Mean Squared Error (RMSE)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Comparison of Algorithm Performance (Lower is Better)'
                        }
                    }
                }
            };

            const rmseChart = new Chart(
                document.getElementById('rmseChart'),
                rmseConfig
            );

            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    document.querySelector(this.getAttribute('href')).scrollIntoView({
                        behavior: 'smooth'
                    });
                });
            });

            // Particle animation logic
            const canvas = document.getElementById('particle-canvas');
            const ctx = canvas.getContext('2d');
            let particles = [];
            const numParticles = 100; // Increased particle count
            const maxLineDistance = 200; // Increased line distance
            const maxVelocity = 0.7; // Increased max velocity for more dynamic movement

            // Adjust canvas size on window resize
            function setCanvasSize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            // Particle class
            class Particle {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.velocity = {
                        x: (Math.random() - 0.5) * maxVelocity,
                        y: (Math.random() - 0.5) * maxVelocity
                    };
                    this.radius = Math.random() * 1.5 + 1;
                    this.color = '#1E90FF'; // A vibrant blue for the particles
                }
                
                // Update particle position
                update() {
                    // Bounce off edges
                    if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
                        this.velocity.x = -this.velocity.x;
                    }
                    if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
                        this.velocity.y = -this.velocity.y;
                    }
                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                }
                
                // Draw particle
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }

            // Create particles
            function init() {
                particles = [];
                for (let i = 0; i < numParticles; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    particles.push(new Particle(x, y));
                }
            }

            // Draw lines between particles that are close to each other
            function drawLines() {
                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < maxLineDistance) {
                            ctx.beginPath();
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            const opacity = 1 - (distance / maxLineDistance);
                            ctx.strokeStyle = `rgba(30, 144, 255, ${opacity})`; // Match line color to particle color
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    }
                }
            }

            // Animation loop
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                particles.forEach(p => {
                    p.update();
                    p.draw();
                });
                drawLines();
                requestAnimationFrame(animate);
            }
            
            // Initial setup
            setCanvasSize();
            init();
            animate();

            // Handle window resize for fluid canvas size
            window.addEventListener('resize', () => {
                setCanvasSize();
                init();
            });
        });
    </script>
</body>
</html>

